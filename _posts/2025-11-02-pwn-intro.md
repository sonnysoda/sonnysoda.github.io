---
layout: post
title: "什么是 PWN？二进制漏洞利用入门"
date: 2025-11-02
---

"PWN" 是一个源自游戏文化的术语，意为“攻破”或“拥有”，在网络安全领域，它特指二进制程序的漏洞利用。PWN 的核心在于找到程序中的内存损坏漏洞，并利用这些漏洞来控制程序的执行流程，最终通常是获取一个 shell（命令行界面），从而完全控制目标系统。

## PWN 的基础：内存与栈

理解 PWN 的关键在于理解程序是如何在内存中运行的。一个程序运行时，其内存通常分为几个区域：代码段、数据段、堆和栈。

*   **栈 (Stack)**: 栈是一块后进先出 (LIFO) 的内存区域，用于存储函数的局部变量、参数和返回地址。当我们调用一个函数时，它的信息（包括返回到哪里继续执行）会被“压入”栈中；当函数返回时，这些信息会被“弹出”。

## 核心漏洞：栈溢出 (Stack Overflow)

栈溢出是最经典和最基础的 PWN 漏洞。它发生在程序向一个栈上的缓冲区写入的数据超过了该缓冲区的容量时。

**漏洞原理**:
假设一个函数有一个 64 字节的缓冲区（比如一个字符数组 `char buffer[64]`），但程序却试图向其中复制 100 字节的数据。多出来的 36 字节数据就会覆盖掉栈上相邻的内存，这其中就可能包括了**函数的返回地址**。

**利用过程**:
1.  **找到漏洞**: 通过代码审计或模糊测试，找到一个可以输入超长数据的点，引发程序崩溃。
2.  **控制返回地址**: 精心构造一串输入数据（称为 `payload`），使其溢出部分能够精确地覆盖函数的返回地址。
3.  **注入 Shellcode**: 在 `payload` 的一部分中，我们放入一小段机器码，这段代码的功能是启动一个 shell（例如 `/bin/sh`）。这就是所谓的 `Shellcode`。
4.  **修改返回地址**: 我们将返回地址修改为我们注入的 `Shellcode` 在内存中的地址。
5.  **获取 Shell**: 当函数执行完毕，准备返回时，它会跳转到我们伪造的返回地址，也就是我们的 `Shellcode` 处。`Shellcode` 执行，我们就成功“PWN”了程序，得到了一个 shell。

## 现代防御机制

为了对抗栈溢出等攻击，现代操作系统引入了多种防御机制：

*   **ASLR (地址空间布局随机化)**: 使得栈、堆等内存区域的地址在每次程序运行时都是随机的，攻击者难以预测 `Shellcode` 的地址。
*   **NX/DEP (不可执行位)**: 将栈等数据区域标记为不可执行，即使攻击者将 `Shellcode` 注入到栈上，也无法执行。
*   **Stack Canaries**: 在返回地址前放置一个随机的特殊值（称为“金丝雀”）。如果缓冲区溢出，这个值会被覆盖。函数返回前会检查这个值是否被改变，如果改变了，就说明发生了溢出，程序会立即终止。

PWN 的世界就是这样一场在攻击与防御之间不断升级的博弈。为了绕过这些防御，攻击者发展出了如 ROP (返回导向编程) 等更高级的技术。

---
*本文内容整合自网络公开资源，旨在提供入门级介绍。*